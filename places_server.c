/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "places.h"
#include "airports.h"
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#define false 0
#define true 1

struct trieNode{
  char *longi;
  char *lat;
  struct trieNode *children[27];
  char value;
};

struct cordinates{
  char *latitude;
  char *longitude;
  bool flag;
};

int convertLetterToIndex(char alphabet){
  if(alphabet >= 'a' && alphabet <= 'z'){
	return alphabet - 'a';
  } else{
	return -1;
  }
}

struct trieNode *initializeTrie(){
  struct trieNode *pNode = NULL;

  pNode = (struct trieNode *)malloc(sizeof(struct trieNode));
  if(pNode){
	pNode->longi = NULL;
	pNode->lat = NULL;
	pNode->value = '\0';
	memset(pNode->children, 0, sizeof(pNode->children));
  }

  return pNode;
}

void trieFree(struct trieNode *root){
  int i;
  if(root){
	for(i = 0; i<= 26; i++){
	  trieFree(root->children[i]);
	}
  }
  free(root);
}

int trieInsert(struct trieNode *node, char *key, char *longitude, char *latitude){
  struct trieNode *parent = node;

  if(key){
	int index = 0;
	int i = 0;

	if(node){
	  while(key[i] != '\0'){
		int indexVal = convertLetterToIndex(key[i]);
		if(!parent->children[indexVal]){
		  parent->children[indexVal] = initializeTrie();
		  parent->children[indexVal]->value = key[i];
		}
		parent = parent->children[indexVal];
		i++;
	  }

	  int longitudeLen = strlen(longitude);
	  int latitudeLen = strlen(latitude);

	  parent->longi = malloc(longitudeLen + 1);
	  strncpy(parent->longi, longitude, longitudeLen + 1);
	  parent->longi[longitudeLen] = '\0';

	  parent->lat = malloc(latitudeLen + 1);
	  strncpy(parent->lat, latitude, latitudeLen + 1);
	  parent->lat[latitudeLen] = '\0';

	}
  }
  return 0;


}

void trimespace(char *str){
  int i;
  int begin = 0;
  int end = strlen(str) - 1;
  while(isspace((unsigned char) str[begin])){
	begin++;
  }

  while((end >= begin) && isspace((unsigned char) str[end])){
	end--;
  }

  for(i = begin; i<= end; i++){
	str[i - begin] = str[i];
  }

  str[i - begin] = '\0';
}

void convertToLower(char *str){
  int i;
  for(i = 0; i < strlen(str); i++){
	str[i] = tolower(str[i]);
  }
}

void removeSpecialChars(char *str){
  int i;
  int j;
  for(i = 0; str[i] != '\0'; ++i){
	while (!( (str[i] >= 'a' && str[i] <= 'z') || (str[i] >= 'A' && str[i] <= 'Z') || str[i] == '\0') )
	  {
		for(j = i; str[j] != '\0'; ++j)
		  {
			str[j] = str[j+1];
		  }
		str[j] = '\0';
	  }
  }


}

char *combine(char *str1, char *str2){
  char *final = malloc(strlen(str1)+ strlen(str2)+ 1);
  strcpy(final, str1);
  strcat(final, str2);
  return final;
}


struct cordinates getTrie(struct trieNode *root, char *key){
  struct trieNode *pNode = root;
  struct cordinates cord;
  if(!key){
	cord.flag = false;
	return cord;
  }

  if(!root){
	cord.flag = false;
	return cord;
  }
  int i = 0;
  while(key[i] != '\0'){
	int indexVal = convertLetterToIndex(key[i]);
	if(!pNode->children[indexVal]){
	  cord.flag = false;
	  return cord;

	}

	pNode = pNode->children[indexVal];
	i++;
  }

  //Check for null values
  //null means the search query needs to refined
  cord.latitude = pNode->lat;
  cord.longitude = pNode->longi;
  cord.flag = true;
  return cord;

}

void readFile(struct trieNode *node){
  FILE *fp;
  fp = fopen("places2k.txt", "r");

  if(fp == NULL){
	printf("Failed opening the file \n");
	fprintf(stderr, "Can't open the file");
	exit(1);
  }
  char fileLine[200];
  char state[3];
  char city[70];
  char latitude[10];
  char longitude[10];
  int counting = 0;
  char *place;

  while(fgets(fileLine, 200,fp )!= NULL){
	strncpy(state,fileLine, 2);
	state[2] = '\0';
	convertToLower(state);

	strncpy(city, fileLine + 9, 63);
	trimespace(city);
	convertToLower(city);
	removeSpecialChars(city);

	place = combine(state, city);

	strncpy(latitude, fileLine + 143, 9);
	latitude[9] = '\0';

	strncpy(longitude, fileLine + 153, 10);
	longitude[10] = '\0';

	trieInsert(node, place, longitude, latitude);
	counting++;

  }

  fclose(fp);

}


places_ret *
places_1_svc(placedata *argp, struct svc_req *rqstp)
{
  static places_ret  result;
  //places_ret result;
  placedata *p = argp;
  char *city = p->name;
  char * state = p->state;
  char *host = "localhost";
  char *searchKey;
  trimespace(city);
  removeSpecialChars(city);
  removeSpecialChars(state);
  convertToLower(city);
  convertToLower(state);
  searchKey = combine(state, city);

  struct trieNode *node = initializeTrie();
  readFile(node);

  struct cordinates checkWord;
  CLIENT *clnt;
  airport_ret  *result_1;
  airportdata  airports_1_arg;

  checkWord = getTrie(node, searchKey);
  airports_1_arg.latitude = atof(checkWord.latitude);
  airports_1_arg.longitude = atof(checkWord.longitude);

#ifndef DEBUG
  clnt = clnt_create (host, AIRPORTPROG, AIRPORT_VERS, "udp");
  if (clnt == NULL) {
	printf("Server Call Failed \n");
	clnt_pcreateerror (host);
	exit (1);
  }
#endif  /* DEBUG */
  placelist *ptr;
  
  printf("Making a remote call to airports \n");
  result_1 = airports_1(&airports_1_arg, clnt);
  if (result_1 == (airport_ret *) NULL) {
	clnt_perror (clnt, "call failed in places server");
  } else {
	airportlist list;
	list = result_1 -> airport_ret_u.list;
	placelist newitem;

	ptr = &result.places_ret_u.list;

	while (list != NULL) {
	  *ptr = (placenode *) malloc (sizeof(placenode));
	  newitem= *ptr;
	  if (newitem != (placenode *)NULL) {
		newitem -> placename = list -> name;
		printf ("%s %s %f %f dist: %f \n", list -> code, list ->name, list -> latitude, list -> longitude, list->distance);
		newitem -> state = "wa";
		newitem -> latitude = (float)10.43;
		newitem ->longitude = (float)12.43;
		ptr = &newitem -> next;
	  }
	  list = list -> next;
	}
  }

#ifndef DEBUG
  clnt_destroy (clnt);
#endif   /* DEBUG */
  *ptr = (placelist)NULL;
  
  result.err = 0;
  
  trieFree(node);
  printf("RETURNING \n");
  return &result;
}
